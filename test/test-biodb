#!/usr/bin/env Rscript
# vi: ft=R
library(RUnit)
library(getopt)
args <- commandArgs(trailingOnly = FALSE)
script.path <- sub("--file=", "", args[grep("--file=", args)])
source(file.path(dirname(script.path), '..', 'BiodbFactory.R'), chdir = TRUE)

#############
# CONSTANTS #
#############

USER.AGENT <- "r-biodb.test ; pierrick.roger@gmail.com"

#############
# READ ARGS #
#############

read.args <- function() {
  
  # program name
  prog <- sub('^.*/([^/]+)$', '\\1', commandArgs()[4], perl = TRUE)
  
  # options
  spec = matrix(c(
    'help',         'h', 0, 'logical',      'Print this help.',
    'name',         'n', 1, 'character',    'Run only test of the specified name. Unset by default.',
    'quick',        'q', 0, 'logical',      'Turn off long tests. Disabled by default.',
    'offline',      'f', 0, 'logical',      'Turn off online tests. Disabled by default.',
    'online',       'o', 0, 'logical',      'Turn off offline tests. Disabled by default.',
    'databases',    'd', 1, 'character',    'Set a restricted list of databases to test. The list must be specified as a comma separated list, no spaces. If unset, test all databases.'
  ), byrow = TRUE, ncol = 5)
   
  opt <- getopt(spec)

  # Help
  if ( ! is.null(opt$help)) {
    cat(getopt(spec, usage = TRUE, command = prog))
    q(status = 0)
  }

  # Process lists
  if ( ! is.null(opt$databases))
	  opt$databases <- strsplit(opt$databases, ",")[[1]]

  return(opt)
}

###########
# TEST DB #
###########

test.db <- function(db) {

	# Test getEntryIds()
	max <- 100
	n <- db$getEntryIds(max.results = max)
	checkTrue(n >= 0 && n <= max)

	# Test getNbEntries()
	n <- db$getNbEntries()
	checkTrue(is.na(n) || n >= 0)
}

################
# TEST ENTRIES #
################

test.entries <- function(db, online = TRUE) {

	# Create factory
	factory <- BiodbFactory$new(useragent = USER.AGENT,
								cache.dir = file.path(dirname(script.path), if (online) 'cache' else file.path('res', 'offline-files')),
								cache.mode = if (online) BIODB.CACHE.WRITE.ONLY else BIODB.CACHE.READ.ONLY,
								debug = TRUE,
								use.env.var = TRUE
								)

	# Test a wrong accession number
	wrong.entry <- factory$createEntry(db, id = 'WRONG')
	checkTrue(is.null(wrong.entry))

	# Download contents
	entries.file <- file.path(dirname(script.path), 'res', paste0(db, '-entries.txt'))
	entries.desc <- read.table(entries.file, stringsAsFactors = FALSE, header = TRUE)

	# Create entries
	entries <- factory$createEntry(db, id = entries.desc[[BIODB.ACCESSION]], drop = FALSE)

	# Test fields of entries
	for (f in colnames(entries.desc)) {
		entries.desc[[f]] <- as.vector(entries.desc[[f]], mode = entries[[1]]$getFieldClass(f))
		card <- entries[[1]]$getFieldCardinality(f)
		e.values <- vapply(entries, function(e) if (card == BIODB.CARD.ONE || is.na(e$getField(f))) e$getField(f) else paste(e$getField(f), collapse = ';'), FUN.VALUE = vector(mode = entries[[1]]$getFieldClass(f), length = 1))
		checkEquals(entries.desc[[f]], e.values, paste0("Error with field \"", f, "\":\nReference: ", paste(entries.desc[[f]], collapse = ", "), "\nValues: ", paste(e.values, collapse = ", ")))
	}
}

########
# MAIN #
########

options(error = function() { traceback(2) ; q(status = 1) }, warn = 2 )

opt <- read.args()

# Define set of functions
if ( ! is.null(opt$name)) {
	test.fcts <- paste0('^', opt$name, '$')
} else {

	# Set prefix
	prefix <- NULL
	if (is.null(opt$online))
		prefix <- c(prefix, 'offline')
	if (is.null(opt$offline))
		prefix <- c(prefix, 'online')
	if ( ! is.null(prefix))
		prefix <- paste0('(', paste(prefix, collapse = '|'), ')\\.')

	# Set databases to test
	dbs <- '\\..+' # all databases by default
	if ( ! is.null(opt$databases))
		dbs <- paste0('\\.(', paste(opt$databases, collapse = '|'), ')')

	# Set test functions
	test.fcts <- paste0('^', prefix, 'test', dbs)
}

test.suite <- defineTestSuite('biodb', dirname(script.path), testFileRegexp = '^test-databases\\.R$', testFuncRegexp = test.fcts)
test.result <- runTestSuite(test.suite)
printTextProtocol(test.result)
